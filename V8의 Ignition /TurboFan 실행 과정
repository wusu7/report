1. 개요

Google의 V8 엔진은 자바스크립트를 빠르고 효율적으로 실행하기 위해
두 단계의 실행 구조를 사용한다.

|단계 	|이름	      |역할
|①	    |Ignition	  |바이트코드를 실행하는 인터프리터
|②	    |TurboFan	  |자주 실행되는 코드(핫 코드)를 기계어로 최적화하는 JIT 컴파일러

이 두 시스템은 "처음엔 가볍게, 자주 쓰이면 더 빠르게"라는 원리로 협력한다.
즉, V8은 실행 중 학습하면서 스스로 최적화되는 엔진이다.

2. Ignition의 역할 — “요리를 시작하는 셰프”

Ignition은 V8의 바이트코드 인터프리터이다.
쉽게 말해, 자바스크립트 코드를 조리하기 좋은 재료(바이트코드)로 손질하는 셰프 역할이다.

$ 동작 과정

>>Parsing (구문 분석)
→ 자바스크립트 코드를 읽고, AST(Abstract Syntax Tree) 형태로 구조화한다.
(요리 레시피를 구조화하는 단계)

>>AST → 바이트코드 변환
→ Ignition이 AST를 바이트코드(Bytecode)로 변환한다.
(재료를 조리하기 좋은 상태로 손질)

>>바이트코드 실행
→ 인터프리터가 한 줄씩 코드를 실행하며,
실행 횟수·패턴 같은 성능 데이터(telemetry)를 수집한다.
(요리하면서 어떤 과정이 오래 걸리는지 기록)

$ 특징

실행이 빠르고 메모리 소모가 적다.

대신 완전한 속도를 내기엔 한계가 있다.

3. TurboFan의 역할 — “자주 만드는 요리를 자동화하는 셰프 로봇”

TurboFan은 V8의 JIT(Just-In-Time) 컴파일러로,
Ignition이 실행 중 수집한 데이터를 이용해
“자주 실행되는 코드(핫 코드)”를 감지하고
이를 기계어(Machine Code)로 변환한다.

즉, 자주 반복되는 요리를 로봇 자동화 시스템으로 바꾸는 과정이다.

$ 동작 과정

>>핫 코드 탐지
→ Ignition이 함수 실행 패턴을 분석해,
“이건 자주 쓰이네?”라고 판단하면 TurboFan을 호출한다.

>>기계어로 컴파일
→ TurboFan이 해당 바이트코드를 분석하여,
CPU가 바로 이해할 수 있는 기계어(Machine Code)로 변환한다.
(요리 과정을 전부 자동화 로봇 레시피로 저장)

>>캐싱 및 재사용
→ 다음에 같은 코드가 실행되면,
이미 만들어둔 기계어를 즉시 실행한다.
(로봇이 바로 요리를 꺼내는 셈)

4. Ignition과 TurboFan 비교 요약
|항목	   |Ignition	                   |TurboFan
|역할	   |빠른 초기                     |실행	자주 실행되는 코드 최적화
|방식	   |인터프리터 (Bytecode 실행)	   |JIT 컴파일러 (Machine Code 생성)
|장점 	 |메모리 절약, 빠른 시작	       |실행 속도 극대화
|결과물   |바이트코드	                 |기계어
|비유	   |손으로 요리하는 셰프	         |자동화 로봇 셰프

5. 결론

Ignition과 TurboFan은 V8의 두 심장이다.

Ignition은 빠른 시작을 담당하며,

TurboFan은 시간이 지날수록 더 빠른 속도를 만들어낸다.

결국 V8 엔진은 이렇게 작동한다:

🔹 “처음엔 인터프리터로 빠르게 시작하고,
🔹 자주 실행되면 컴파일러로 변신해 더 빠르게 달린다.”

즉, “학습하는 엔진”이며,
속도와 효율을 동시에 잡은 똑똑한 실행 구조다.
